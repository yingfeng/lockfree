package algorithms.published;

/**
 * Implementation of dictionary ADT with a non-blocking AVL search tree.
 * Copyright (C) 2013 Ken Hoover
 * Contact (khoover@cs.toronto.edu) with questions or comments.
 * Optimized by Trevor Brown (me [at] tbrown [dot] pro).
 *
 * Based on Trevor Brown's implementation of the dictionary ADT with a
 * chromatic search tree, located at
 *
 * http://www.cs.utoronto.ca/~tabrown/chromatic/ChromaticSearchTree.java
 * 
 * This optimized version performs rebalancing only once a path from the root
 * to a leaf contains at least d violations of the red-black tree invariants,
 * where d is a constant specified when an instance of the tree is created.
 * Increasing d decreases the number of rotations that must be performed
 * at the cost of increasing search time. Since searches are extremely fast,
 * this trade off is often very beneficial for moderate values of d.
 * When d = 0, each put() or remove() fixes any violation it created before
 * returning to the caller.
 *
 * This data structure has:
 *  -- entirely non-blocking (also called lock-free) operations
 *  -- height that is O(c+d+log n), where n is the number of keys in the
 *     dictionary, d is the constant mentioned above, and c is the number of
 *     insertions and deletions currently in progress.
 *     (the constants hidden by the big-O notation are small.)
 * 
 * If there is interest in using this data structure, but it lacks some basic
 * functionality that is required, Trevor Brown is open to expanding this work.
 * For instance, it is possible to add:
 *  -- the ability to atomically { remove any number of nodes/keys/values
 *     (even if they are scattered throughout the tree), and add one },
 *  -- linearizable size(), clone(), iterators, range queries, and
 *  -- the ability to compose operations by layering transactional memory
 *     on top of the fast non-blocking operations offered by this tree.
 * 
 * As an interesting side note, less than 550 lines of code in this file were
 * written by hand.  The remainder were generated by a computer program,
 * which can be adapted to produce code for other balanced trees.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.Comparator;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

public class LockFreeRelaxedAVLMap<K, V> {
    private final int d; // number of violations to allow on a search path before we fix everything on it
    private static final int DEFAULT_d = 15; // experimentally determined to yield good performance for both random workloads, and operations on sorted sequences
    private final Node root;
    private final Operation dummy;
    private final Comparator<? super K> comparator;
    private final AtomicReferenceFieldUpdater<LockFreeRelaxedAVLMap.Node, LockFreeRelaxedAVLMap.Node> updateLeft, updateRight;
    private final AtomicReferenceFieldUpdater<LockFreeRelaxedAVLMap.Node, LockFreeRelaxedAVLMap.Operation> updateOp;

    public LockFreeRelaxedAVLMap() {
        this(DEFAULT_d, null); 
    }
    public LockFreeRelaxedAVLMap(final Comparator<? super K> cmp) {
        this(DEFAULT_d, cmp);
    }
    public LockFreeRelaxedAVLMap(final int allowedViolationsPerPath) {
        this(allowedViolationsPerPath, null);
    }
    public LockFreeRelaxedAVLMap(final int allowedViolationsPerPath, final Comparator<? super K> cmp) {
        d = allowedViolationsPerPath;
        comparator = cmp;
        updateLeft = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left");
        updateRight = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right");
        updateOp = AtomicReferenceFieldUpdater.newUpdater(Node.class, Operation.class, "op");
        dummy = new Operation();
        root = new Node(null, null, 0, 0, new Node(null, null, 0, 0, null, null, dummy), null, dummy);
    }

    /**
     * size() is NOT a constant time method, and the result is only guaranteed to
     * be consistent if no concurrent updates occur.
     * Note: linearizable size() and iterators can be implemented, so contact
     *       the author if they are needed for some application.
     */
    public final int size() {
        return sequentialSize(root);
    }
    private int sequentialSize(final Node node) {
        if (node == null) return 0;
        if (node.left == null && node.key != null) return 1;
        return sequentialSize(node.left) + sequentialSize(node.right);
    }

    public final boolean containsKey(final K key) {
        return get(key) != null;
    }

    public final V get(final K key) {
        assert (key != null);
        final Comparable k = comparable(key);

        Node node = root.left;
        if (node.left == null) {
            return null; // no keys in data structure
        }
        node = node.left;

        while (node.left != null) {
            node = (k.compareTo(node.key) < 0) ? node.left : node.right;
        }
        return (k.compareTo(node.key) == 0) ? (V) node.value : null;
    }

    public final V put(final K key, final V value) {
        return doPut(key, value, false);
    }

    public final V putIfAbsent(final K key, final V value) {
        return doPut(key, value, true);
    }

    private V doPut(final K key, final V value, final boolean onlyIfAbsent) {
        assert (key != null && value != null);
        final Comparable k = comparable(key);
        boolean found = false;
        Operation op = null;
        Node p, l = null;
        int count = 0;

        while (true) {
            while (op == null) {
                p = root;
                l = root.left;
                if (l.left != null) {
                    count = 0;
                    p = l;
                    l = l.left; // note: l must have key infinity, and l.left must not.
                    while (l.left != null) {
                        if (d > 0 && l.tag != 0) ++count;
                        p = l;
                        l = (k.compareTo(l.key) < 0) ? l.left : l.right;
                    }
                }

                // if we find the key in the tree already
                if (l.key != null && k.compareTo(l.key) == 0) {
                    found = true;
                    if (onlyIfAbsent) {
                        return (V) l.value;
                    }
                    op = createReplaceOp(p, l, key, value);
                } else {
                    found = false;
                    op = createInsertOp(p, l, key, value, k);
                }
            }
            final Node[] nodes = op.nodes;
            if (helpSCX(op, 0)) {
                // clean up violations if necessary
                if (d == 0) {
                    if (!found && nodes[0].tag == 0) fixToKey(k);
                } else {
                    if (count >= d) fixToKey(k);
                }
                // we may have found the key and replaced its value (the old value is stored in the old node)
                return (found ? (V) l.value : null);
            }
            op = null;
        }
    }

    public final V remove(final K key) {
        assert (key != null);
        final Comparable k = comparable(key);
        Node gp, p = null, l = null;
        Operation op = null;
        int count = 0;

        while (true) {
            while (op == null) {
                gp = root;
                p = root;
                l = root.left;
                if (l.left != null) {
                    gp = p;
                    p = l;
                    l = l.left; // note: l must have key infinity, and l.left must not.
                    count = 0;
                    while (l.left != null) {
                        if (d > 0 && l.tag != 0) ++count;
                        gp = p;
                        p = l;
                        l = (k.compareTo(l.key) < 0) ? l.left : l.right;
                    }
                }

                // the key was not in the tree at the linearization point, so no value was removed
                if (l.key == null || k.compareTo(l.key) != 0) {
                    return null;
                }
                op = createDeleteOp(gp, p, l);
            }
            final Node[] nodes = op.nodes;
            if (helpSCX(op, 0)) {
                // clean up violations if necessary
                if (d == 0) {
                    if ((p.tag >= 0 || ((l == p.left) ? r(p) : l(p)) == 1) && !isSentinel(nodes[1])) fixToKey(k);
                } else {
                    if (count >= d) fixToKey(k);
                }
                // we deleted a key, so we return the removed value (saved in the old node)
                return (V) l.value;
            }
            op = null;
        }
    }

    public final void fixToKey(final Comparable<? super K> k) {
        while (true) {
            Node gp, p, l = root.left;
            if (l.left == null) {
                return; // only sentinels in tree...
            }
            gp = root;
            p = l;
            l = l.left; // note: l must have key infinity, and l.left must not.
            while (l.left != null && l.tag == 0) {
                gp = p;
                p = l;
                l = (k.compareTo((K) l.key) < 0) ? l.left : l.right;
            }
            if (l.tag == 0) {
                return; // (if no violation, then the search hit a leaf, so we can stop)
            }
            final Operation op = createBalancingOp(gp, p, l);
            if (op != null) {
                helpSCX(op, 0);
            }
        }
    }

    @SuppressWarnings("unchecked")
    private Comparable<? super K> comparable(final Object key) {
        if (key == null) {
            throw new NullPointerException();
        }
        if (comparator == null) {
            return (Comparable<? super K>)key;
        }
        return new Comparable<K>() {
            @SuppressWarnings("unchecked")
            public int compareTo(final K rhs) { return comparator.compare((K)key, rhs); }
        };
    }

    private boolean isSentinel(final Node node) {
        return (node.key == null || node == root.left.left);
    }

    // This weaker form of LLX does not return a linearizable snapshot.
    // However, we do not use the fact that LLX returns a snapshot anywhere in
    //   the proof of SCX (help), and we do not need the snapshot capability
    //   to satisfy the precondition of SCX (that there be an LLX linked to SCX
    //   for each node in V).
    // Note: using a full LLX slows things by ~3%.
    private Operation weakLLX(final Node r) {
        final Operation rinfo = r.op;
        final int state = rinfo.state;
        if (state == Operation.STATE_ABORTED || (state == Operation.STATE_COMMITTED && !r.marked)) {
            return rinfo;
        }
        if (rinfo.state == Operation.STATE_INPROGRESS) {
            helpSCX(rinfo, 1);
        } else if (r.op.state == Operation.STATE_INPROGRESS) {
            helpSCX(r.op, 1);
        }
        return null;
    }
    // helper function to use the results of a weakLLX more conveniently
    private boolean weakLLX(final Node r, final int i, final Operation[] ops, final Node[] nodes) {
        if ((ops[i] = weakLLX(r)) == null) return false;
        nodes[i] = r;
        return true;
    }
    
    // this function is essentially an SCX without the creation of V, R, fld, new
    // (which are stored in an operation object).
    // the creation of the operation object is simply inlined in other methods.
    private boolean helpSCX(final Operation op, int i) {
        // get local references to some fields of op, in case we later null out fields of op (to help the garbage collector)
        final Node[] nodes = op.nodes;
        final Operation[] ops = op.ops;
        final Node subtree = op.subtree;
        // if we see aborted or committed, no point in helping (already done).
        // further, if committed, variables may have been nulled out to help the garbage collector.
        // so, we return.
        if (op.state != Operation.STATE_INPROGRESS) return true;
        
        // freeze sub-tree
        for (; i<ops.length; ++i) {
            if (!updateOp.compareAndSet(nodes[i], ops[i], op) && nodes[i].op != op) { // if work was not done
                if (op.allFrozen) {
                    return true;
                } else {
                    op.state = Operation.STATE_ABORTED;
                    // help the garbage collector (must be AFTER we set state committed or aborted)
                    op.nodes = null;
                    op.ops = null;
                    op.subtree = null;
                    return false;
                }
            }
        }
        op.allFrozen = true;
        for (i=1; i<ops.length; ++i) nodes[i].marked = true; // finalize all but first node
        
        // CAS in the new sub-tree (child-cas)
        if (nodes[0].left == nodes[1]) {
            updateLeft.compareAndSet(nodes[0], nodes[1], subtree);     // splice in new sub-tree (as a left child)
        } else { // assert: nodes[0].right == nodes[1]
            updateRight.compareAndSet(nodes[0], nodes[1], subtree);    // splice in new sub-tree (as a right child)
        }
        op.state = Operation.STATE_COMMITTED;
        
        // help the garbage collector (must be AFTER we set state committed or aborted)
        op.nodes = null;
        op.ops = null;
        op.subtree = null;
        return true;
    }

    private Operation createInsertOp(final Node p, final Node l, final K key, final V value, Comparable k) {
        final Operation[] ops = new Operation[1];
        final Node[] nodes = new Node[]{null, l};

        if (!weakLLX(p, 0, ops, nodes)) {
            return null;
        }
        final boolean left = (l == p.left);
        if (!left && l != p.right) {
            return null;
        }

        // Compute the tag for the new parent node
        final int newTag = (isSentinel(l) ? 0 : l.tag - 1);               // (maintain sentinel tags at 0)

        // Build new sub-tree
        final Node newLeaf = new Node(key, value, 0, 0, null, null, dummy);
        final Node newL = new Node(l.key, l.value, 0, 0, null, null, dummy);
        final Node newP;
        if (l.key == null || k.compareTo(l.key) < 0) {
            newP = new Node(l.key, l.value, newTag, 0, newLeaf, newL, dummy);
        } else {
            newP = new Node(key, value, newTag, 0, newL, newLeaf, dummy);
        }
        return new Operation(nodes, ops, newP);
    }

    // Just like insert, except this replaces an existing value.
    private Operation createReplaceOp(final Node p, final Node l, final K key, final V value) {
        final Operation[] ops = new Operation[1];
        final Node[] nodes = new Node[]{null, l};

        if (!weakLLX(p, 0, ops, nodes)) {
            return null;
        }
        if (l != p.left && l != p.right) {
            return null;
        }

        // Build new sub-tree
        final Node subtree = new Node(key, value, l.tag, l.balance, l.left, l.right, dummy);
        return new Operation(nodes, ops, subtree);
    }

    private Operation createDeleteOp(final Node gp, final Node p, final Node l) {
        final Operation opGP = weakLLX(gp);
        if (opGP == null) {
            return null;
        }
        final Operation opP = weakLLX(p);
        if (opP == null) {
            return null;
        }

        if (p != gp.left && p != gp.right) {
            return null;
        }
        final boolean left = (l == p.left);
        if (!left && l != p.right) {
            return null;
        }
        final Node s = left ? p.right : p.left;
        // Now, if the op. succeeds, all structure is guaranteed to be just as we verified

        // Compute tag for the new node (to replace to deleted leaf l and parent p)
        final int newTag = (isSentinel(p) ? 0 : p.tag + s.tag + 1 + (left ? l(p) : r(p))); // tags of parent + sibling of deleted leaf, plus fudge factor

        // Read fields for the sibling of l into ops[2], nodes[2] = s
        final Operation opS = weakLLX(s);
        if (opS == null) {
            return null;
        }
        // Build new sub-tree
        final Node newP = new Node(s.key, s.value, newTag, s.balance, s.left, s.right, dummy);
        return new Operation(new Node[]{gp, p, s}, new Operation[]{opGP, opP, opS}, newP);
    }

    private Operation createBalancingOp(final Node f, final Node fX, final Node fXX) {
        final Operation opf = weakLLX(f);
        if (opf == null || !f.hasChild(fX)) {
            return null;
        }

        final Operation opfX = weakLLX(fX);
        if (opfX == null) {
            return null;
        }
        final Node fXL = fX.left;
        final Node fXR = fX.right;
        final boolean fXXleft = (fXX == fXL);
        if (!fXXleft && fXX != fXR) {
            return null;
        }

        // negative tag violation
        if (fXX.tag == -1) {
            if (fXXleft) {
                final Operation opfXL = weakLLX(fXL);
                if (opfXL == null) {
                    return null;
                }
                return createNegativeLeftOp(f, fX, fXL, opf, opfX, opfXL);
            } else {
                final Operation opfXR = weakLLX(fXR);
                if (opfXR == null) {
                    return null;
                }
                return createNegativeRightOp(f, fX, fXR, opf, opfX, opfXR);
            }
        } else { // assert(fXX.tag > 0); // otherwise fXX isn't a violation, and fixToKey wouldn't have invoked this.
            final Operation opfXL = weakLLX(fXL);
            if (opfXL == null) {
                return null;
            }
            final Operation opfXR = weakLLX(fXR);
            if (opfXR == null) {
                return null;
            }
            if (fXXleft) {
                if (fXR.tag == -1) { // fix negatives first
                    return createNegativeRightOp(f, fX, fXR, opf, opfX, opfXR);
                } else {
                    return createPositiveLeftOp(f, fX, fXL, fXR, opf, opfX, opfXL, opfXR);
                }
            } else {
                if (fXL.tag == -1) {
                    return createNegativeLeftOp(f, fX, fXL, opf, opfX, opfXL);
                } else {
                    return createPositiveRightOp(f, fX, fXR, fXL, opf, opfX, opfXR, opfXL);
                }
            }
        }
    }

    private Operation createNegativeLeftOp(final Node f, final Node fX, final Node fXL,
            final Operation opf, final Operation opfX, final Operation opfXL) {
        if (fX.balance <= 0) {
            return createPullOp(new Node[]{f, fX, fXL}, new Operation[]{opf, opfX, opfXL});
        } else { // assert(fX.balance == 1);
            if (fXL.balance >= 0) {
                return createPul5Op(new Node[]{f, fX, fXL}, new Operation[]{opf, opfX, opfXL});
            } else { // assert(fXL.balance == -1);
                final Node fXLR = fXL.right;
                final Operation opfXLR = weakLLX(fXLR);
                if (opfXLR == null) {
                    return null;
                }
                if (fXLR.tag == -1) {
                    return createPul8Op(new Node[]{f, fX, fXL, fXLR}, new Operation[]{opf, opfX, opfXL, opfXLR});
                } else if (fXLR.tag == 0) {
                    return createPul7Op(new Node[]{f, fX, fXL, fXLR}, new Operation[]{opf, opfX, opfXL, opfXLR});
                } else {
                    return createPul6Op(new Node[]{f, fX, fXL, fXLR}, new Operation[]{opf, opfX, opfXL, opfXLR});
                }
            }
        }
    }

    private Operation createPositiveLeftOp(final Node f, final Node fX, final Node fXL, final Node fXR,
            final Operation opf, final Operation opfX, final Operation opfXL, final Operation opfXR) {
        if (fX.balance >= 0) {
            return createPushOp(new Node[]{f, fX, fXL}, new Operation[]{opf, opfX, opfXL});
        } else { // assert(fX.balance == -1);
            if (fXR.tag > 0) {
                return createPsh9Op(new Node[]{f, fX, fXL, fXR}, new Operation[]{opf, opfX, opfXL, opfXR});
            } else { // assert(fXR.tag == 0);
                if (fXR.balance <= 0) {
                    return createPsh10Op(new Node[]{f, fX, fXL, fXR}, new Operation[]{opf, opfX, opfXL, opfXR});
                } else { // assert(fXR.balance == 1);
                    final Node fXRL = fXR.left;
                    final Operation opfXRL = weakLLX(fXRL);
                    if (opfXRL == null) {
                        return null;
                    }
                    if (fXRL.tag == -1) {
                        return createPsh13Op(new Node[]{f, fX, fXL, fXR, fXRL}, new Operation[]{opf, opfX, opfXL, opfXR, opfXRL});
                    } else if (fXRL.tag == 0) {
                        return createPsh12Op(new Node[]{f, fX, fXL, fXR, fXRL}, new Operation[]{opf, opfX, opfXL, opfXR, opfXRL});
                    } else {
                        return createPsh11Op(new Node[]{f, fX, fXL, fXR, fXRL}, new Operation[]{opf, opfX, opfXL, opfXR, opfXRL});
                    }
                }
            }
        }
    }

    public static final class Node {
        public final Object key;
        public final Object value;
        public final int tag;
        public final int balance;
        public volatile Node left, right;
        public volatile Operation op;
        public volatile boolean marked;

        public Node(final Object key, final Object value, final int tag, final int balance, final Node left, final Node right, final Operation op) {
            this.key = key;
            this.value = value;
            this.balance = balance;
            this.tag = tag;
            this.left = left;
            this.right = right;
            this.op = op;
        }

        public final boolean hasChild(final Node node) {
            return node == left || node == right;
        }

        public final String toString() {
            if (key == null) {
                return "null:null[0:0]";
            }
            return key.toString() + "[" + Integer.toString(balance) + ":" + Integer.toString(tag) + "]";
        }
    }

    public final int r(final Node n) {
        return (n.balance == -1 ? 1 : 0);
    }

    public final int l(final Node n) {
        return (n.balance == 1 ? 1 : 0);
    }

    public static final class Operation {
        final static int STATE_INPROGRESS = 0;
        final static int STATE_ABORTED = 1;
        final static int STATE_COMMITTED = 2;
        
        volatile Node subtree;
        volatile Node[] nodes;
        volatile Operation[] ops;
        volatile int state;
        volatile boolean allFrozen;

        public Operation() {            // create an dummy operation [[ we have null fields rather than smaller records simply to avoid the overhead of inheritance ]]
            nodes = null;
            ops = null;
            subtree = null;
            this.state = STATE_ABORTED; // cheap trick to piggy-back on a pre-existing check for frozen nodes
        }

        public Operation(final Node[] nodes, final Operation[] ops, final Node subtree) {
            this.nodes = nodes;
            this.ops = ops;
            this.subtree = subtree;
        }
    }

    /**
     * Computer generated code past here
     */
    
    private Operation createNegativeRightOp(final Node f, final Node fX, final Node fXR,
            final Operation opf, final Operation opfX, final Operation opfXR) {
        if (fX.balance >= 0) {
            return createPullSymOp(new Node[]{f, fX, fXR}, new Operation[]{opf, opfX, opfXR});
        } else { // assert(fX.balance == -1);
            if (fXR.balance <= 0) {
                return createPul5SymOp(new Node[]{f, fX, fXR}, new Operation[]{opf, opfX, opfXR});
            } else { // assert(fXR.balance == 1);
                final Node fXRL = fXR.left;
                final Operation opfXRL = weakLLX(fXRL);
                if (opfXRL == null) {
                    return null;
                }
                if (fXRL.tag == -1) {
                    return createPul8SymOp(new Node[]{f, fX, fXR, fXRL}, new Operation[]{opf, opfX, opfXR, opfXRL});
                } else if (fXRL.tag == 0) {
                    return createPul7SymOp(new Node[]{f, fX, fXR, fXRL}, new Operation[]{opf, opfX, opfXR, opfXRL});
                } else {
                    return createPul6SymOp(new Node[]{f, fX, fXR, fXRL}, new Operation[]{opf, opfX, opfXR, opfXRL});
                }
            }
        }
    }

    private Operation createPositiveRightOp(final Node f, final Node fX, final Node fXR, final Node fXL,
            final Operation opf, final Operation opfX, final Operation opfXR, final Operation opfXL) {
        if (fX.balance <= 0) {
            return createPushSymOp(new Node[]{f, fX, fXR}, new Operation[]{opf, opfX, opfXR});
        } else { // assert(fX.balance == -1);
            if (fXL.tag > 0) {
                return createPsh9SymOp(new Node[]{f, fX, fXL, fXR}, new Operation[]{opf, opfX, opfXL, opfXR});
            } else { // assert(fXL.tag == 0);
                if (fXL.balance >= 0) {
                    return createPsh10SymOp(new Node[]{f, fX, fXL, fXR}, new Operation[]{opf, opfX, opfXL, opfXR});
                } else { // assert(fXL.balance == -1);
                    final Node fXLR = fXL.right;
                    final Operation opfXLR = weakLLX(fXLR);
                    if (opfXLR == null) {
                        return null;
                    }
                    if (fXLR.tag == -1) {
                        return createPsh13SymOp(new Node[]{f, fX, fXL, fXR, fXLR}, new Operation[]{opf, opfX, opfXL, opfXR, opfXLR});
                    } else if (fXLR.tag == 0) {
                        return createPsh12SymOp(new Node[]{f, fX, fXL, fXR, fXLR}, new Operation[]{opf, opfX, opfXL, opfXR, opfXLR});
                    } else {
                        return createPsh11SymOp(new Node[]{f, fX, fXL, fXR, fXLR}, new Operation[]{opf, opfX, opfXL, opfXR, opfXLR});
                    }
                }
            }
        }
    }

    // Rotations
    private Operation createPullOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1 + r(nodes[1])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, nodes[1].balance + 1, nodeXL, nodes[1].right, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPushOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + l(nodes[1])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, nodes[1].balance - 1, nodeXL, nodes[1].right, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul5Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, 1 - l(nodes[2]), nodes[2].right, nodes[1].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1 + l(nodes[2])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[2].key, nodes[2].value, tag, nodes[2].balance - 1, nodes[2].left, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul6Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXLR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, 0, nodes[2].left, nodeXLR, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, 1, nodeXL, nodes[1].right, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul7Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, r(nodes[3]), nodes[2].left, nodes[3].left, dummy);
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, -l(nodes[3]), nodes[3].right, nodes[1].right, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[3].key, nodes[3].value, tag, 0, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul8Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, r(nodes[3]) - 1, nodes[2].left, nodes[3].left, dummy);
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, 1 - l(nodes[3]), nodes[3].right, nodes[1].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[3].key, nodes[3].value, tag, nodes[3].balance, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh9Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, -1, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh10Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[3]) - 1, nodeXLL, nodes[3].left, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + r(nodes[3])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[3].key, nodes[3].value, tag, nodes[3].balance + 1, nodeXL, nodes[3].right, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh11Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXRL = new Node(nodes[4].key, nodes[4].value, nodes[4].tag - 1, nodes[4].balance, nodes[4].left, nodes[4].right, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, 0, 0, nodeXRL, nodes[3].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, -1, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh12Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[4]), nodeXLL, nodes[4].left, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, 0, -l(nodes[4]), nodes[4].right, nodes[3].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[4].key, nodes[4].value, tag, 0, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh13Op(final Node[] nodes, final Operation[] ops) {
        final Node nodeXLL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[4]) - 1, nodeXLL, nodes[4].left, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, 0, 1 - l(nodes[4]), nodes[4].right, nodes[3].right, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[4].key, nodes[4].value, tag, nodes[4].balance, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPullSymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXR = new Node(nodes[2].key, nodes[2].value, 0, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1 + l(nodes[1])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, nodes[1].balance - 1, nodes[1].left, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPushSymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXR = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + r(nodes[1])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, nodes[1].balance + 1, nodes[1].left, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul5SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[2]) - 1, nodes[1].left, nodes[2].left, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1 + r(nodes[2])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[2].key, nodes[2].value, tag, nodes[2].balance + 1, nodeXL, nodes[2].right, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul6SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXRL = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final Node nodeXR = new Node(nodes[2].key, nodes[2].value, 0, 0, nodeXRL, nodes[2].right, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, -1, nodes[1].left, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul7SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[3]), nodes[1].left, nodes[3].left, dummy);
        final Node nodeXR = new Node(nodes[2].key, nodes[2].value, 0, -l(nodes[3]), nodes[3].right, nodes[2].right, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[3].key, nodes[3].value, tag, 0, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPul8SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[1].key, nodes[1].value, 0, r(nodes[3]) - 1, nodes[1].left, nodes[3].left, dummy);
        final Node nodeXR = new Node(nodes[2].key, nodes[2].value, 0, 1 - l(nodes[3]), nodes[3].right, nodes[2].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag - 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[3].key, nodes[3].value, tag, nodes[3].balance, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh9SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, nodes[2].tag - 1, nodes[2].balance, nodes[2].left, nodes[2].right, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, 1, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh10SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, 1 - l(nodes[2]), nodes[2].right, nodeXRR, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + l(nodes[2])); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[2].key, nodes[2].value, tag, nodes[2].balance - 1, nodes[2].left, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh11SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXLR = new Node(nodes[4].key, nodes[4].value, nodes[4].tag - 1, nodes[4].balance, nodes[4].left, nodes[4].right, dummy);
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, 0, nodes[2].left, nodeXLR, dummy);
        final Node nodeXR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[1].key, nodes[1].value, tag, 1, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh12SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, r(nodes[4]), nodes[2].left, nodes[4].left, dummy);
        final Node nodeXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, -l(nodes[4]), nodes[4].right, nodeXRR, dummy);
        final int tag = (isSentinel(nodes[1]) ? 0 : nodes[1].tag + 1); // root of old subtree is a sentinel
        final Node nodeX = new Node(nodes[4].key, nodes[4].value, tag, 0, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }

    private Operation createPsh13SymOp(final Node[] nodes, final Operation[] ops) {
        final Node nodeXL = new Node(nodes[2].key, nodes[2].value, 0, r(nodes[4]) - 1, nodes[2].left, nodes[4].left, dummy);
        final Node nodeXRR = new Node(nodes[3].key, nodes[3].value, nodes[3].tag - 1, nodes[3].balance, nodes[3].left, nodes[3].right, dummy);
        final Node nodeXR = new Node(nodes[1].key, nodes[1].value, 0, 1 - l(nodes[4]), nodes[4].right, nodeXRR, dummy);
        final int tag = nodes[1].tag;
        final Node nodeX = new Node(nodes[4].key, nodes[4].value, tag, nodes[4].balance, nodeXL, nodeXR, dummy);
        return new Operation(nodes, ops, nodeX);
    }
    
}
